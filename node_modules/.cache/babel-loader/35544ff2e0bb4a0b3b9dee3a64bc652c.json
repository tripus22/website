{"ast":null,"code":"import _toConsumableArray from \"/home/emily/Documents/spring22/capstone/website/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _objectSpread from \"/home/emily/Documents/spring22/capstone/website/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nimport { devAssert } from '../jsutils/devAssert.mjs';\nimport { inspect } from '../jsutils/inspect.mjs';\nimport { invariant } from '../jsutils/invariant.mjs';\nimport { keyMap } from '../jsutils/keyMap.mjs';\nimport { mapValue } from '../jsutils/mapValue.mjs';\nimport { Kind } from '../language/kinds.mjs';\nimport { isTypeDefinitionNode, isTypeExtensionNode } from '../language/predicates.mjs';\nimport { GraphQLEnumType, GraphQLInputObjectType, GraphQLInterfaceType, GraphQLList, GraphQLNonNull, GraphQLObjectType, GraphQLScalarType, GraphQLUnionType, isEnumType, isInputObjectType, isInterfaceType, isListType, isNonNullType, isObjectType, isScalarType, isUnionType } from '../type/definition.mjs';\nimport { GraphQLDeprecatedDirective, GraphQLDirective, GraphQLSpecifiedByDirective } from '../type/directives.mjs';\nimport { introspectionTypes, isIntrospectionType } from '../type/introspection.mjs';\nimport { isSpecifiedScalarType, specifiedScalarTypes } from '../type/scalars.mjs';\nimport { assertSchema, GraphQLSchema } from '../type/schema.mjs';\nimport { assertValidSDLExtension } from '../validation/validate.mjs';\nimport { getDirectiveValues } from '../execution/values.mjs';\nimport { valueFromAST } from './valueFromAST.mjs';\n/**\n * Produces a new schema given an existing schema and a document which may\n * contain GraphQL type extensions and definitions. The original schema will\n * remain unaltered.\n *\n * Because a schema represents a graph of references, a schema cannot be\n * extended without effectively making an entire copy. We do not know until it's\n * too late if subgraphs remain unchanged.\n *\n * This algorithm copies the provided schema, applying extensions while\n * producing the copy. The original schema remains unaltered.\n */\n\nexport function extendSchema(schema, documentAST, options) {\n  assertSchema(schema);\n  documentAST != null && documentAST.kind === Kind.DOCUMENT || devAssert(false, 'Must provide valid Document AST.');\n\n  if ((options === null || options === void 0 ? void 0 : options.assumeValid) !== true && (options === null || options === void 0 ? void 0 : options.assumeValidSDL) !== true) {\n    assertValidSDLExtension(documentAST, schema);\n  }\n\n  var schemaConfig = schema.toConfig();\n  var extendedConfig = extendSchemaImpl(schemaConfig, documentAST, options);\n  return schemaConfig === extendedConfig ? schema : new GraphQLSchema(extendedConfig);\n}\n/**\n * @internal\n */\n\nexport function extendSchemaImpl(schemaConfig, documentAST, options) {\n  var _schemaDef, _schemaDef$descriptio, _schemaDef2, _options$assumeValid; // Collect the type definitions and extensions found in the document.\n\n\n  var typeDefs = [];\n  var typeExtensionsMap = Object.create(null); // New directives and types are separate because a directives and types can\n  // have the same name. For example, a type named \"skip\".\n\n  var directiveDefs = [];\n  var schemaDef; // Schema extensions are collected which may add additional operation types.\n\n  var schemaExtensions = [];\n\n  var _iterator = _createForOfIteratorHelper(documentAST.definitions),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var def = _step.value;\n\n      if (def.kind === Kind.SCHEMA_DEFINITION) {\n        schemaDef = def;\n      } else if (def.kind === Kind.SCHEMA_EXTENSION) {\n        schemaExtensions.push(def);\n      } else if (isTypeDefinitionNode(def)) {\n        typeDefs.push(def);\n      } else if (isTypeExtensionNode(def)) {\n        var extendedTypeName = def.name.value;\n        var existingTypeExtensions = typeExtensionsMap[extendedTypeName];\n        typeExtensionsMap[extendedTypeName] = existingTypeExtensions ? existingTypeExtensions.concat([def]) : [def];\n      } else if (def.kind === Kind.DIRECTIVE_DEFINITION) {\n        directiveDefs.push(def);\n      }\n    } // If this document contains no new types, extensions, or directives then\n    // return the same unmodified GraphQLSchema instance.\n\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  if (Object.keys(typeExtensionsMap).length === 0 && typeDefs.length === 0 && directiveDefs.length === 0 && schemaExtensions.length === 0 && schemaDef == null) {\n    return schemaConfig;\n  }\n\n  var typeMap = Object.create(null);\n\n  var _iterator2 = _createForOfIteratorHelper(schemaConfig.types),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var existingType = _step2.value;\n      typeMap[existingType.name] = extendNamedType(existingType);\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n\n  for (var _i = 0, _typeDefs = typeDefs; _i < _typeDefs.length; _i++) {\n    var typeNode = _typeDefs[_i];\n\n    var _stdTypeMap$name;\n\n    var name = typeNode.name.value;\n    typeMap[name] = (_stdTypeMap$name = stdTypeMap[name]) !== null && _stdTypeMap$name !== void 0 ? _stdTypeMap$name : buildType(typeNode);\n  }\n\n  var operationTypes = _objectSpread({\n    // Get the extended root operation types.\n    query: schemaConfig.query && replaceNamedType(schemaConfig.query),\n    mutation: schemaConfig.mutation && replaceNamedType(schemaConfig.mutation),\n    subscription: schemaConfig.subscription && replaceNamedType(schemaConfig.subscription)\n  }, schemaDef && getOperationTypes([schemaDef]), getOperationTypes(schemaExtensions)); // Then produce and return a Schema config with these types.\n\n\n  return _objectSpread({\n    description: (_schemaDef = schemaDef) === null || _schemaDef === void 0 ? void 0 : (_schemaDef$descriptio = _schemaDef.description) === null || _schemaDef$descriptio === void 0 ? void 0 : _schemaDef$descriptio.value\n  }, operationTypes, {\n    types: Object.values(typeMap),\n    directives: [].concat(_toConsumableArray(schemaConfig.directives.map(replaceDirective)), _toConsumableArray(directiveDefs.map(buildDirective))),\n    extensions: Object.create(null),\n    astNode: (_schemaDef2 = schemaDef) !== null && _schemaDef2 !== void 0 ? _schemaDef2 : schemaConfig.astNode,\n    extensionASTNodes: schemaConfig.extensionASTNodes.concat(schemaExtensions),\n    assumeValid: (_options$assumeValid = options === null || options === void 0 ? void 0 : options.assumeValid) !== null && _options$assumeValid !== void 0 ? _options$assumeValid : false\n  }); // Below are functions used for producing this schema that have closed over\n  // this scope and have access to the schema, cache, and newly defined types.\n\n  function replaceType(type) {\n    if (isListType(type)) {\n      // @ts-expect-error\n      return new GraphQLList(replaceType(type.ofType));\n    }\n\n    if (isNonNullType(type)) {\n      // @ts-expect-error\n      return new GraphQLNonNull(replaceType(type.ofType));\n    } // @ts-expect-error FIXME\n\n\n    return replaceNamedType(type);\n  }\n\n  function replaceNamedType(type) {\n    // Note: While this could make early assertions to get the correctly\n    // typed values, that would throw immediately while type system\n    // validation with validateSchema() will produce more actionable results.\n    return typeMap[type.name];\n  }\n\n  function replaceDirective(directive) {\n    var config = directive.toConfig();\n    return new GraphQLDirective(_objectSpread({}, config, {\n      args: mapValue(config.args, extendArg)\n    }));\n  }\n\n  function extendNamedType(type) {\n    if (isIntrospectionType(type) || isSpecifiedScalarType(type)) {\n      // Builtin types are not extended.\n      return type;\n    }\n\n    if (isScalarType(type)) {\n      return extendScalarType(type);\n    }\n\n    if (isObjectType(type)) {\n      return extendObjectType(type);\n    }\n\n    if (isInterfaceType(type)) {\n      return extendInterfaceType(type);\n    }\n\n    if (isUnionType(type)) {\n      return extendUnionType(type);\n    }\n\n    if (isEnumType(type)) {\n      return extendEnumType(type);\n    }\n\n    if (isInputObjectType(type)) {\n      return extendInputObjectType(type);\n    }\n    /* c8 ignore next 3 */\n    // Not reachable, all possible type definition nodes have been considered.\n\n\n    false || invariant(false, 'Unexpected type: ' + inspect(type));\n  }\n\n  function extendInputObjectType(type) {\n    var _typeExtensionsMap$co;\n\n    var config = type.toConfig();\n    var extensions = (_typeExtensionsMap$co = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co !== void 0 ? _typeExtensionsMap$co : [];\n    return new GraphQLInputObjectType(_objectSpread({}, config, {\n      fields: function fields() {\n        return _objectSpread({}, mapValue(config.fields, function (field) {\n          return _objectSpread({}, field, {\n            type: replaceType(field.type)\n          });\n        }), buildInputFieldMap(extensions));\n      },\n      extensionASTNodes: config.extensionASTNodes.concat(extensions)\n    }));\n  }\n\n  function extendEnumType(type) {\n    var _typeExtensionsMap$ty;\n\n    var config = type.toConfig();\n    var extensions = (_typeExtensionsMap$ty = typeExtensionsMap[type.name]) !== null && _typeExtensionsMap$ty !== void 0 ? _typeExtensionsMap$ty : [];\n    return new GraphQLEnumType(_objectSpread({}, config, {\n      values: _objectSpread({}, config.values, buildEnumValueMap(extensions)),\n      extensionASTNodes: config.extensionASTNodes.concat(extensions)\n    }));\n  }\n\n  function extendScalarType(type) {\n    var _typeExtensionsMap$co2;\n\n    var config = type.toConfig();\n    var extensions = (_typeExtensionsMap$co2 = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co2 !== void 0 ? _typeExtensionsMap$co2 : [];\n    var specifiedByURL = config.specifiedByURL;\n\n    var _iterator3 = _createForOfIteratorHelper(extensions),\n        _step3;\n\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var extensionNode = _step3.value;\n\n        var _getSpecifiedByURL;\n\n        specifiedByURL = (_getSpecifiedByURL = getSpecifiedByURL(extensionNode)) !== null && _getSpecifiedByURL !== void 0 ? _getSpecifiedByURL : specifiedByURL;\n      }\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n\n    return new GraphQLScalarType(_objectSpread({}, config, {\n      specifiedByURL: specifiedByURL,\n      extensionASTNodes: config.extensionASTNodes.concat(extensions)\n    }));\n  }\n\n  function extendObjectType(type) {\n    var _typeExtensionsMap$co3;\n\n    var config = type.toConfig();\n    var extensions = (_typeExtensionsMap$co3 = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co3 !== void 0 ? _typeExtensionsMap$co3 : [];\n    return new GraphQLObjectType(_objectSpread({}, config, {\n      interfaces: function interfaces() {\n        return [].concat(_toConsumableArray(type.getInterfaces().map(replaceNamedType)), _toConsumableArray(buildInterfaces(extensions)));\n      },\n      fields: function fields() {\n        return _objectSpread({}, mapValue(config.fields, extendField), buildFieldMap(extensions));\n      },\n      extensionASTNodes: config.extensionASTNodes.concat(extensions)\n    }));\n  }\n\n  function extendInterfaceType(type) {\n    var _typeExtensionsMap$co4;\n\n    var config = type.toConfig();\n    var extensions = (_typeExtensionsMap$co4 = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co4 !== void 0 ? _typeExtensionsMap$co4 : [];\n    return new GraphQLInterfaceType(_objectSpread({}, config, {\n      interfaces: function interfaces() {\n        return [].concat(_toConsumableArray(type.getInterfaces().map(replaceNamedType)), _toConsumableArray(buildInterfaces(extensions)));\n      },\n      fields: function fields() {\n        return _objectSpread({}, mapValue(config.fields, extendField), buildFieldMap(extensions));\n      },\n      extensionASTNodes: config.extensionASTNodes.concat(extensions)\n    }));\n  }\n\n  function extendUnionType(type) {\n    var _typeExtensionsMap$co5;\n\n    var config = type.toConfig();\n    var extensions = (_typeExtensionsMap$co5 = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co5 !== void 0 ? _typeExtensionsMap$co5 : [];\n    return new GraphQLUnionType(_objectSpread({}, config, {\n      types: function types() {\n        return [].concat(_toConsumableArray(type.getTypes().map(replaceNamedType)), _toConsumableArray(buildUnionTypes(extensions)));\n      },\n      extensionASTNodes: config.extensionASTNodes.concat(extensions)\n    }));\n  }\n\n  function extendField(field) {\n    return _objectSpread({}, field, {\n      type: replaceType(field.type),\n      args: field.args && mapValue(field.args, extendArg)\n    });\n  }\n\n  function extendArg(arg) {\n    return _objectSpread({}, arg, {\n      type: replaceType(arg.type)\n    });\n  }\n\n  function getOperationTypes(nodes) {\n    var opTypes = {};\n\n    var _iterator4 = _createForOfIteratorHelper(nodes),\n        _step4;\n\n    try {\n      for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n        var node = _step4.value;\n\n        var _node$operationTypes; // FIXME: https://github.com/graphql/graphql-js/issues/2203\n\n\n        var operationTypesNodes =\n        /* c8 ignore next */\n        (_node$operationTypes = node.operationTypes) !== null && _node$operationTypes !== void 0 ? _node$operationTypes : [];\n\n        var _iterator5 = _createForOfIteratorHelper(operationTypesNodes),\n            _step5;\n\n        try {\n          for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n            var operationType = _step5.value;\n            // Note: While this could make early assertions to get the correctly\n            // typed values below, that would throw immediately while type system\n            // validation with validateSchema() will produce more actionable results.\n            // @ts-expect-error\n            opTypes[operationType.operation] = getNamedType(operationType.type);\n          }\n        } catch (err) {\n          _iterator5.e(err);\n        } finally {\n          _iterator5.f();\n        }\n      }\n    } catch (err) {\n      _iterator4.e(err);\n    } finally {\n      _iterator4.f();\n    }\n\n    return opTypes;\n  }\n\n  function getNamedType(node) {\n    var _stdTypeMap$name2;\n\n    var name = node.name.value;\n    var type = (_stdTypeMap$name2 = stdTypeMap[name]) !== null && _stdTypeMap$name2 !== void 0 ? _stdTypeMap$name2 : typeMap[name];\n\n    if (type === undefined) {\n      throw new Error(\"Unknown type: \\\"\".concat(name, \"\\\".\"));\n    }\n\n    return type;\n  }\n\n  function getWrappedType(node) {\n    if (node.kind === Kind.LIST_TYPE) {\n      return new GraphQLList(getWrappedType(node.type));\n    }\n\n    if (node.kind === Kind.NON_NULL_TYPE) {\n      return new GraphQLNonNull(getWrappedType(node.type));\n    }\n\n    return getNamedType(node);\n  }\n\n  function buildDirective(node) {\n    var _node$description;\n\n    return new GraphQLDirective({\n      name: node.name.value,\n      description: (_node$description = node.description) === null || _node$description === void 0 ? void 0 : _node$description.value,\n      // @ts-expect-error\n      locations: node.locations.map(function (_ref) {\n        var value = _ref.value;\n        return value;\n      }),\n      isRepeatable: node.repeatable,\n      args: buildArgumentMap(node.arguments),\n      astNode: node\n    });\n  }\n\n  function buildFieldMap(nodes) {\n    var fieldConfigMap = Object.create(null);\n\n    var _iterator6 = _createForOfIteratorHelper(nodes),\n        _step6;\n\n    try {\n      for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n        var node = _step6.value;\n\n        var _node$fields; // FIXME: https://github.com/graphql/graphql-js/issues/2203\n\n\n        var nodeFields =\n        /* c8 ignore next */\n        (_node$fields = node.fields) !== null && _node$fields !== void 0 ? _node$fields : [];\n\n        var _iterator7 = _createForOfIteratorHelper(nodeFields),\n            _step7;\n\n        try {\n          for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n            var field = _step7.value;\n\n            var _field$description;\n\n            fieldConfigMap[field.name.value] = {\n              // Note: While this could make assertions to get the correctly typed\n              // value, that would throw immediately while type system validation\n              // with validateSchema() will produce more actionable results.\n              type: getWrappedType(field.type),\n              description: (_field$description = field.description) === null || _field$description === void 0 ? void 0 : _field$description.value,\n              args: buildArgumentMap(field.arguments),\n              deprecationReason: getDeprecationReason(field),\n              astNode: field\n            };\n          }\n        } catch (err) {\n          _iterator7.e(err);\n        } finally {\n          _iterator7.f();\n        }\n      }\n    } catch (err) {\n      _iterator6.e(err);\n    } finally {\n      _iterator6.f();\n    }\n\n    return fieldConfigMap;\n  }\n\n  function buildArgumentMap(args) {\n    // FIXME: https://github.com/graphql/graphql-js/issues/2203\n    var argsNodes =\n    /* c8 ignore next */\n    args !== null && args !== void 0 ? args : [];\n    var argConfigMap = Object.create(null);\n\n    var _iterator8 = _createForOfIteratorHelper(argsNodes),\n        _step8;\n\n    try {\n      for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n        var arg = _step8.value;\n\n        var _arg$description; // Note: While this could make assertions to get the correctly typed\n        // value, that would throw immediately while type system validation\n        // with validateSchema() will produce more actionable results.\n\n\n        var type = getWrappedType(arg.type);\n        argConfigMap[arg.name.value] = {\n          type: type,\n          description: (_arg$description = arg.description) === null || _arg$description === void 0 ? void 0 : _arg$description.value,\n          defaultValue: valueFromAST(arg.defaultValue, type),\n          deprecationReason: getDeprecationReason(arg),\n          astNode: arg\n        };\n      }\n    } catch (err) {\n      _iterator8.e(err);\n    } finally {\n      _iterator8.f();\n    }\n\n    return argConfigMap;\n  }\n\n  function buildInputFieldMap(nodes) {\n    var inputFieldMap = Object.create(null);\n\n    var _iterator9 = _createForOfIteratorHelper(nodes),\n        _step9;\n\n    try {\n      for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n        var node = _step9.value;\n\n        var _node$fields2; // FIXME: https://github.com/graphql/graphql-js/issues/2203\n\n\n        var fieldsNodes =\n        /* c8 ignore next */\n        (_node$fields2 = node.fields) !== null && _node$fields2 !== void 0 ? _node$fields2 : [];\n\n        var _iterator10 = _createForOfIteratorHelper(fieldsNodes),\n            _step10;\n\n        try {\n          for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n            var field = _step10.value;\n\n            var _field$description2; // Note: While this could make assertions to get the correctly typed\n            // value, that would throw immediately while type system validation\n            // with validateSchema() will produce more actionable results.\n\n\n            var type = getWrappedType(field.type);\n            inputFieldMap[field.name.value] = {\n              type: type,\n              description: (_field$description2 = field.description) === null || _field$description2 === void 0 ? void 0 : _field$description2.value,\n              defaultValue: valueFromAST(field.defaultValue, type),\n              deprecationReason: getDeprecationReason(field),\n              astNode: field\n            };\n          }\n        } catch (err) {\n          _iterator10.e(err);\n        } finally {\n          _iterator10.f();\n        }\n      }\n    } catch (err) {\n      _iterator9.e(err);\n    } finally {\n      _iterator9.f();\n    }\n\n    return inputFieldMap;\n  }\n\n  function buildEnumValueMap(nodes) {\n    var enumValueMap = Object.create(null);\n\n    var _iterator11 = _createForOfIteratorHelper(nodes),\n        _step11;\n\n    try {\n      for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n        var node = _step11.value;\n\n        var _node$values; // FIXME: https://github.com/graphql/graphql-js/issues/2203\n\n\n        var valuesNodes =\n        /* c8 ignore next */\n        (_node$values = node.values) !== null && _node$values !== void 0 ? _node$values : [];\n\n        var _iterator12 = _createForOfIteratorHelper(valuesNodes),\n            _step12;\n\n        try {\n          for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {\n            var value = _step12.value;\n\n            var _value$description;\n\n            enumValueMap[value.name.value] = {\n              description: (_value$description = value.description) === null || _value$description === void 0 ? void 0 : _value$description.value,\n              deprecationReason: getDeprecationReason(value),\n              astNode: value\n            };\n          }\n        } catch (err) {\n          _iterator12.e(err);\n        } finally {\n          _iterator12.f();\n        }\n      }\n    } catch (err) {\n      _iterator11.e(err);\n    } finally {\n      _iterator11.f();\n    }\n\n    return enumValueMap;\n  }\n\n  function buildInterfaces(nodes) {\n    // Note: While this could make assertions to get the correctly typed\n    // values below, that would throw immediately while type system\n    // validation with validateSchema() will produce more actionable results.\n    // @ts-expect-error\n    return nodes.flatMap( // FIXME: https://github.com/graphql/graphql-js/issues/2203\n    function (node) {\n      var _node$interfaces$map, _node$interfaces;\n\n      return (\n        /* c8 ignore next */\n        (_node$interfaces$map = (_node$interfaces = node.interfaces) === null || _node$interfaces === void 0 ? void 0 : _node$interfaces.map(getNamedType)) !== null && _node$interfaces$map !== void 0 ? _node$interfaces$map : []\n      );\n    });\n  }\n\n  function buildUnionTypes(nodes) {\n    // Note: While this could make assertions to get the correctly typed\n    // values below, that would throw immediately while type system\n    // validation with validateSchema() will produce more actionable results.\n    // @ts-expect-error\n    return nodes.flatMap( // FIXME: https://github.com/graphql/graphql-js/issues/2203\n    function (node) {\n      var _node$types$map, _node$types;\n\n      return (\n        /* c8 ignore next */\n        (_node$types$map = (_node$types = node.types) === null || _node$types === void 0 ? void 0 : _node$types.map(getNamedType)) !== null && _node$types$map !== void 0 ? _node$types$map : []\n      );\n    });\n  }\n\n  function buildType(astNode) {\n    var _typeExtensionsMap$na;\n\n    var name = astNode.name.value;\n    var extensionASTNodes = (_typeExtensionsMap$na = typeExtensionsMap[name]) !== null && _typeExtensionsMap$na !== void 0 ? _typeExtensionsMap$na : [];\n\n    switch (astNode.kind) {\n      case Kind.OBJECT_TYPE_DEFINITION:\n        {\n          var _astNode$description;\n\n          var allNodes = [astNode].concat(_toConsumableArray(extensionASTNodes));\n          return new GraphQLObjectType({\n            name: name,\n            description: (_astNode$description = astNode.description) === null || _astNode$description === void 0 ? void 0 : _astNode$description.value,\n            interfaces: function interfaces() {\n              return buildInterfaces(allNodes);\n            },\n            fields: function fields() {\n              return buildFieldMap(allNodes);\n            },\n            astNode: astNode,\n            extensionASTNodes: extensionASTNodes\n          });\n        }\n\n      case Kind.INTERFACE_TYPE_DEFINITION:\n        {\n          var _astNode$description2;\n\n          var _allNodes = [astNode].concat(_toConsumableArray(extensionASTNodes));\n\n          return new GraphQLInterfaceType({\n            name: name,\n            description: (_astNode$description2 = astNode.description) === null || _astNode$description2 === void 0 ? void 0 : _astNode$description2.value,\n            interfaces: function interfaces() {\n              return buildInterfaces(_allNodes);\n            },\n            fields: function fields() {\n              return buildFieldMap(_allNodes);\n            },\n            astNode: astNode,\n            extensionASTNodes: extensionASTNodes\n          });\n        }\n\n      case Kind.ENUM_TYPE_DEFINITION:\n        {\n          var _astNode$description3;\n\n          var _allNodes2 = [astNode].concat(_toConsumableArray(extensionASTNodes));\n\n          return new GraphQLEnumType({\n            name: name,\n            description: (_astNode$description3 = astNode.description) === null || _astNode$description3 === void 0 ? void 0 : _astNode$description3.value,\n            values: buildEnumValueMap(_allNodes2),\n            astNode: astNode,\n            extensionASTNodes: extensionASTNodes\n          });\n        }\n\n      case Kind.UNION_TYPE_DEFINITION:\n        {\n          var _astNode$description4;\n\n          var _allNodes3 = [astNode].concat(_toConsumableArray(extensionASTNodes));\n\n          return new GraphQLUnionType({\n            name: name,\n            description: (_astNode$description4 = astNode.description) === null || _astNode$description4 === void 0 ? void 0 : _astNode$description4.value,\n            types: function types() {\n              return buildUnionTypes(_allNodes3);\n            },\n            astNode: astNode,\n            extensionASTNodes: extensionASTNodes\n          });\n        }\n\n      case Kind.SCALAR_TYPE_DEFINITION:\n        {\n          var _astNode$description5;\n\n          return new GraphQLScalarType({\n            name: name,\n            description: (_astNode$description5 = astNode.description) === null || _astNode$description5 === void 0 ? void 0 : _astNode$description5.value,\n            specifiedByURL: getSpecifiedByURL(astNode),\n            astNode: astNode,\n            extensionASTNodes: extensionASTNodes\n          });\n        }\n\n      case Kind.INPUT_OBJECT_TYPE_DEFINITION:\n        {\n          var _astNode$description6;\n\n          var _allNodes4 = [astNode].concat(_toConsumableArray(extensionASTNodes));\n\n          return new GraphQLInputObjectType({\n            name: name,\n            description: (_astNode$description6 = astNode.description) === null || _astNode$description6 === void 0 ? void 0 : _astNode$description6.value,\n            fields: function fields() {\n              return buildInputFieldMap(_allNodes4);\n            },\n            astNode: astNode,\n            extensionASTNodes: extensionASTNodes\n          });\n        }\n    }\n  }\n}\nvar stdTypeMap = keyMap([].concat(_toConsumableArray(specifiedScalarTypes), _toConsumableArray(introspectionTypes)), function (type) {\n  return type.name;\n});\n/**\n * Given a field or enum value node, returns the string value for the\n * deprecation reason.\n */\n\nfunction getDeprecationReason(node) {\n  var deprecated = getDirectiveValues(GraphQLDeprecatedDirective, node); // @ts-expect-error validated by `getDirectiveValues`\n\n  return deprecated === null || deprecated === void 0 ? void 0 : deprecated.reason;\n}\n/**\n * Given a scalar node, returns the string value for the specifiedByURL.\n */\n\n\nfunction getSpecifiedByURL(node) {\n  var specifiedBy = getDirectiveValues(GraphQLSpecifiedByDirective, node); // @ts-expect-error validated by `getDirectiveValues`\n\n  return specifiedBy === null || specifiedBy === void 0 ? void 0 : specifiedBy.url;\n}","map":null,"metadata":{},"sourceType":"module"}